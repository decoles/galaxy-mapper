{"ast":null,"code":"import * as THREE from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport Stats from \"three/examples/jsm/libs/stats.module\";\nexport default class SceneInit {\n  constructor() {\n    let fov = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 36;\n    let camera = arguments.length > 1 ? arguments[1] : undefined;\n    let scene = arguments.length > 2 ? arguments[2] : undefined;\n    let stats = arguments.length > 3 ? arguments[3] : undefined;\n    let controls = arguments.length > 4 ? arguments[4] : undefined;\n    let renderer = arguments.length > 5 ? arguments[5] : undefined;\n    this.fov = fov;\n    this.scene = scene;\n    this.stats = stats;\n    this.camera = camera;\n    this.controls = controls;\n    this.renderer = renderer;\n  }\n\n  initScene() {\n    this.camera = new THREE.PerspectiveCamera(this.fov, window.innerWidth / window.innerHeight, 1, 1000);\n    this.camera.position.z = 128;\n    this.scene = new THREE.Scene(); //const spaceTexture = new THREE.TextureLoader().load(\"/textures/space2.jpg\");\n    //this.scene.background = spaceTexture;\n    // specify a canvas which is already created in the HTML file and tagged by an id\n    // aliasing enabled\n\n    this.renderer = new THREE.WebGLRenderer({\n      canvas: document.getElementById(\"myThreeJsCanvas\"),\n      antialias: true\n    });\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.renderer.shadowMap.enabled = true;\n    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; //Default THREE.PCFShadowMap\n\n    document.body.appendChild(this.renderer.domElement);\n    this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n    this.stats = Stats();\n    document.body.appendChild(this.stats.dom);\n    const color = 0xFFFFFF;\n    const intensity = 1.0;\n    const directionalLight = new THREE.DirectionalLight(color, intensity);\n    this.scene.add(directionalLight); //Initlize the stars\n\n    var vertices = [];\n    var numPoints = 10000;\n\n    for (var i = 0; i < numPoints; i++) {\n      var x = THREE.MathUtils.randFloatSpread(1000);\n      var y = THREE.MathUtils.randFloatSpread(1000);\n      var z = THREE.MathUtils.randFloatSpread(1000);\n      vertices.push(x, y, z);\n    }\n\n    var geometry = new THREE.BufferGeometry();\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n    var material = new THREE.PointsMaterial({\n      color: 0xb4b4b4,\n      sizeAttenuation: false,\n      size: 1\n    });\n    var points = new THREE.Points(geometry, material);\n    this.scene.add(points); // if window resizes\n\n    window.addEventListener(\"resize\", () => this.onWindowResize(), false);\n  }\n\n  animate() {\n    requestAnimationFrame(this.animate.bind(this));\n    this.render();\n    this.stats.update(); // Update the position of the directional light here\n\n    const time = performance.now() * 0.001; // Use time or any other variable to control the movement\n\n    const radius = 100; // Radius of the circular path\n\n    const centerX = 0; // X coordinate of the center\n\n    const centerY = 0; // Y coordinate of the center\n\n    const x = centerX + Math.cos(time) * radius;\n    const y = centerY + Math.sin(time) * radius; // Get the existing directional light from the scene\n\n    const directionalLight = this.scene.getObjectByName('directionalLight'); // Check if the directional light already exists in the scene\n\n    if (directionalLight) {\n      // Update the position of the existing directional light\n      directionalLight.position.set(x, y, 0);\n    } else {\n      // Create a new directional light and add it to the scene\n      const color = 0xFFFFFF;\n      const intensity = 1.0;\n      const newDirectionalLight = new THREE.DirectionalLight(color, intensity);\n      newDirectionalLight.position.set(x, y, 0);\n      newDirectionalLight.name = 'directionalLight'; // Set a name to identify it\n\n      this.scene.add(newDirectionalLight);\n    }\n  }\n\n  render() {\n    this.renderer.render(this.scene, this.camera); //this.renderer.shadowMap.enabled = true;\n  }\n\n  onWindowResize() {\n    this.camera.aspect = window.innerWidth / window.innerHeight;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n  }\n\n}","map":{"version":3,"names":["THREE","OrbitControls","Stats","SceneInit","constructor","fov","camera","scene","stats","controls","renderer","initScene","PerspectiveCamera","window","innerWidth","innerHeight","position","z","Scene","WebGLRenderer","canvas","document","getElementById","antialias","setSize","shadowMap","enabled","type","PCFSoftShadowMap","body","appendChild","domElement","dom","color","intensity","directionalLight","DirectionalLight","add","vertices","numPoints","i","x","MathUtils","randFloatSpread","y","push","geometry","BufferGeometry","setAttribute","Float32BufferAttribute","material","PointsMaterial","sizeAttenuation","size","points","Points","addEventListener","onWindowResize","animate","requestAnimationFrame","bind","render","update","time","performance","now","radius","centerX","centerY","Math","cos","sin","getObjectByName","set","newDirectionalLight","name","aspect","updateProjectionMatrix"],"sources":["/home/decoles/projects/galaxy-mapper/frontend/src/components/galaxyMap/SceneInitialization.jsx"],"sourcesContent":["import * as THREE from \"three\";\r\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\r\nimport Stats from \"three/examples/jsm/libs/stats.module\";\r\n\r\nexport default class SceneInit {\r\n  constructor(fov = 36, camera, scene, stats, controls, renderer) {\r\n    this.fov = fov;\r\n    this.scene = scene;\r\n    this.stats = stats;\r\n    this.camera = camera;\r\n    this.controls = controls;\r\n    this.renderer = renderer;\r\n  }\r\n\r\n  initScene() {\r\n    this.camera = new THREE.PerspectiveCamera(\r\n      this.fov,\r\n      window.innerWidth / window.innerHeight,\r\n      1,\r\n      1000\r\n    );\r\n    this.camera.position.z = 128;\r\n\r\n    this.scene = new THREE.Scene();\r\n\r\n    //const spaceTexture = new THREE.TextureLoader().load(\"/textures/space2.jpg\");\r\n    //this.scene.background = spaceTexture;\r\n\r\n    // specify a canvas which is already created in the HTML file and tagged by an id\r\n    // aliasing enabled\r\n    this.renderer = new THREE.WebGLRenderer({\r\n      canvas: document.getElementById(\"myThreeJsCanvas\"),\r\n      antialias: true,\r\n    });\r\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\r\n    this.renderer.shadowMap.enabled = true;\r\n    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; //Default THREE.PCFShadowMap\r\n    document.body.appendChild(this.renderer.domElement);\r\n\r\n    this.controls = new OrbitControls(this.camera, this.renderer.domElement);\r\n\r\n    this.stats = Stats();\r\n    document.body.appendChild(this.stats.dom);\r\n\r\n    const color = 0xFFFFFF;\r\n    const intensity = 1.0;\r\n\r\n\r\n    const directionalLight = new THREE.DirectionalLight(color, intensity);\r\n    this.scene.add(directionalLight);\r\n\r\n\r\n    //Initlize the stars\r\n    var vertices = []; \r\n    var numPoints = 10000;\r\n    for (var i = 0; i < numPoints; i++) {\r\n        var x = THREE.MathUtils.randFloatSpread(1000);\r\n        var y = THREE.MathUtils.randFloatSpread(1000);\r\n        var z = THREE.MathUtils.randFloatSpread(1000);\r\n        vertices.push(x, y, z);\r\n    } \r\n    var geometry = new THREE.BufferGeometry();\r\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\r\n    var material = new THREE.PointsMaterial({\r\n        color: 0xb4b4b4,\r\n        sizeAttenuation: false,\r\n        size: 1,\r\n    });\r\n    var points = new THREE.Points(geometry, material);\r\n    this.scene.add(points);\r\n\r\n    // if window resizes\r\n    window.addEventListener(\"resize\", () => this.onWindowResize(), false);\r\n  }\r\n\r\n  animate() {\r\n    requestAnimationFrame(this.animate.bind(this));\r\n    this.render();\r\n    this.stats.update();\r\n  \r\n    // Update the position of the directional light here\r\n    const time = performance.now() * 0.001; // Use time or any other variable to control the movement\r\n    const radius = 100; // Radius of the circular path\r\n    const centerX = 0; // X coordinate of the center\r\n    const centerY = 0; // Y coordinate of the center\r\n  \r\n    const x = centerX + Math.cos(time) * radius;\r\n    const y = centerY + Math.sin(time) * radius;\r\n  \r\n    // Get the existing directional light from the scene\r\n    const directionalLight = this.scene.getObjectByName('directionalLight');\r\n  \r\n    // Check if the directional light already exists in the scene\r\n    if (directionalLight) {\r\n      // Update the position of the existing directional light\r\n      directionalLight.position.set(x, y, 0);\r\n    } else {\r\n      // Create a new directional light and add it to the scene\r\n      const color = 0xFFFFFF;\r\n      const intensity = 1.0;\r\n      const newDirectionalLight = new THREE.DirectionalLight(color, intensity);\r\n      newDirectionalLight.position.set(x, y, 0);\r\n      newDirectionalLight.name = 'directionalLight'; // Set a name to identify it\r\n      this.scene.add(newDirectionalLight);\r\n    }\r\n  }\r\n\r\n  render() {\r\n    this.renderer.render(this.scene, this.camera);\r\n    //this.renderer.shadowMap.enabled = true;\r\n  }\r\n\r\n  onWindowResize() {\r\n    this.camera.aspect = window.innerWidth / window.innerHeight;\r\n    this.camera.updateProjectionMatrix();\r\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\r\n  }\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}